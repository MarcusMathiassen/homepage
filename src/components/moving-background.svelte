<style>
canvas {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    z-index: -999;
}
</style>

<canvas
    bind:this={canvas}
></canvas>

<script>

    import { onMount } from 'svelte'

    import { v2, mat4 } from './utils/math'
    import { randFloat } from './utils/utility'

    export let movingBackgroundOptions

    let startTime = 0
    let textColor
    let backColor

    let gl
    let vao
    let vbo = new Map()
    let program

    let gAttribLocationViewportSize = 4

    let verticesAttribLocation = 0
    let positionsAttribLocation = 1
    let colorsAttribLocation = 2
    let sizesAttribLocation = 3

    let canvas
    let canvasWidth = 300
    let canvasHeight = 300

    let bindTo = 'moving-background'
    let numVerticesPerCircle = movingBackgroundOptions.verticesPerParticle
    let desiredPrimitiveCount = movingBackgroundOptions.particleCount
    let particleSize = movingBackgroundOptions.particleSize

    let lastPrimitiveCount = 0
    let primitiveCount = 0

    let lastInfo = {
        verticesLength: 0,
        positionsLength: 0,
        colorsLength: 0,
        sizesLength: 0,
    }

    let vertices = []
    let positions = []
    let colors = []
    let sizes = []

    let GPUBuffersNeedingUpdate = {
        vertices: false,
        positions: false,
        colors: false,
        sizes: false
    }

    let velocities = []
    const getTime = () => {
        return (new Date().getTime() - startTime) / 1000
    }
    const updateGPUBuffers = async () => {
        if (GPUBuffersNeedingUpdate.vertices) {
            await updateVertices()
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo.get('vertices'))
            const verticesLength = vertices.length
            if (verticesLength >= lastInfo.verticesLength) {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW)
                lastInfo.verticesLength = verticesLength
            } else gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(vertices), 0, 0)
        }

        if (GPUBuffersNeedingUpdate.positions) {
            await updatePositions()
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo.get('positions'))
            const positionsLength = positions.length
            if (positionsLength >= lastInfo.positionsLength) {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW)
                lastInfo.positionsLength = positionsLength
            } else gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(positions), 0, 0)
        }

        if (GPUBuffersNeedingUpdate.colors) {
            await updateColors()
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo.get('colors'))
            const colorsLength = colors.length
            if (colorsLength >= lastInfo.colorsLength) {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW)
                lastInfo.colorsLength = colorsLength
            } else gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(colors), 0, 0)
        }

        if (GPUBuffersNeedingUpdate.sizes) {
            await updateSizes()
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo.get('sizes'))
            const sizesLength = sizes.length
            if (sizesLength >= lastInfo.sizesLength) {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.DYNAMIC_DRAW)
                lastInfo.sizesLength = sizesLength
            } else gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(sizes), 0, 0)
        }
        for (let prop in GPUBuffersNeedingUpdate) prop = false
    }

    const normalize = rgba => {
        return {
            r: rgba.r / 255,
            g: rgba.g / 255,
            b: rgba.b / 255,
            a: rgba.a || rgba.a / 255,
        }
    }

    function updateVertices() {
        numVerticesPerCircle = Math.floor(Math.abs(Math.sin(getTime())*12)+3)
        // Add vertices
        vertices = []
        for (let i = 0; i < numVerticesPerCircle; ++i) {
            const cont = i * Math.PI * 2 / numVerticesPerCircle
            vertices.push(Math.cos(cont), Math.sin(cont))
        }
    }
    function updateValues () {
        canvasWidth = window.innerWidth
        canvasHeight = window.innerHeight

        var desiredCSSWidth = canvasWidth
        var desiredCSSHeight = canvasHeight
        devicePixelRatio = window.devicePixelRatio || 1

        canvas.width = desiredCSSWidth * devicePixelRatio
        canvas.height = desiredCSSHeight * devicePixelRatio

        canvas.style.width = desiredCSSWidth + 'px'
        canvas.style.height = desiredCSSHeight + 'px'

        canvasWidth *= devicePixelRatio
        canvasHeight *= devicePixelRatio

        textColor = normalize(window.color.text)
        textColor.a = 0.2

        backColor = normalize(window.color.background)
        backColor.a = 1.0

        // GPUBuffersNeedingUpdate.colors = true
    }

    async function updatePositions() {
        for (let i = 0; i < primitiveCount * 2; i += 2) {
            let posx = positions[i]
            let posy = positions[i+1]

            let velx = velocities[i]
            let vely = velocities[i+1]

            let size = sizes[i / 2 - 1]

            if (posx >= canvasWidth - size) {
                posx = canvasWidth - size
                velx = -velx
            }
            if (posx <= size) {
                posx = size
                velx = -velx
            }
            if (posy >= canvasHeight - size) {
                posy = canvasHeight - size
                vely = -vely
            }
            if (posy <= size) {
                posy = size
                vely = -vely
            }

            posx += velx * 0.05
            posy += vely * 0.05

            positions[i] = posx
            positions[i+1] = posy

            velocities[i] = velx
            velocities[i+1] = vely
        }
    }
    async function updateColors() {
        for (let i = 0; i < primitiveCount*4; i += 4) {
            colors[i]   = textColor.r
            colors[i+1] = textColor.g
            colors[i+2] = textColor.b
            colors[i+3] = textColor.a
        }
    }
    async function updateSizes() {
        for (let i = 0; i < primitiveCount; ++i) {
            sizes[i] = Math.abs(Math.sin(getTime()) * 1) + 1
        }
    }

    async function draw() {
        updateValues()

        // GPUBuffersNeedingUpdate.vertices = true
        GPUBuffersNeedingUpdate.positions = true
        // GPUBuffersNeedingUpdate.sizes = true

        gl.clearColor(backColor.r,backColor.g,backColor.b, backColor.a)
        gl.clear(gl.COLOR_BUFFER_BIT)

        // Setup viewport, orthographic projection matrix
        gl.viewport(0, 0, canvasWidth, canvasHeight)

        gl.useProgram(program)
        gl.bindVertexArray(vao)
        gl.uniform2f(gAttribLocationViewportSize, canvasWidth, canvasHeight)

        const type = gl.TRIANGLE_FAN
        const first = 0
        const count = numVerticesPerCircle
        const primitive_count = primitiveCount

        await updateGPUBuffers()
        gl.drawArraysInstanced(type, first, count, primitive_count)

        window.requestAnimationFrame(await draw)

        lastPrimitiveCount = primitiveCount
    }

    onMount(async () => {

        gl = canvas.getContext("webgl2")

        if (!gl)  {
            console.error("no webgl2 context found. stopping.")
            return 
        }

        gl.enable(gl.BLEND)
        gl.blendEquation(gl.FUNC_ADD)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

        program = gl.createProgram()
        let vs = gl.createShader(gl.VERTEX_SHADER)
        let fs = gl.createShader(gl.FRAGMENT_SHADER)

        let vs_src = `#version 300 es
        precision highp float;

        in vec2     vertices;
        in vec2     position;
        in vec4     color;
        in float    size;

        uniform vec2 viewport_size;

        out vec4 color0;

        void main() {
            vec2 pos = (((size * vertices + position) / viewport_size) * 2.0) - 1.0;
            gl_Position = vec4(pos, 0.0, 1.0);
            color0 = color;
        }
        `

        let fs_src = `#version 300 es
        precision highp float;
        in vec4 color0;
        out vec4 frag;
        void main() {
            frag = color0;
        }`

        gl.shaderSource(vs, vs_src)
        gl.shaderSource(fs, fs_src)

        gl.compileShader(vs)
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
            console.error(
                'ERROR compiling vertex shader!',
                gl.getShaderInfoLog(vs)
            )
            return
        }

        gl.compileShader(fs)
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            console.error(
                'ERROR compiling fragment shader!',
                gl.getShaderInfoLog(fs)
            )
            return
        }

        gl.attachShader(program, vs)
        gl.attachShader(program, fs)

        gl.bindAttribLocation(program, verticesAttribLocation, 'vertices')
        gl.bindAttribLocation(program, positionsAttribLocation, 'position')
        gl.bindAttribLocation(program, colorsAttribLocation, 'color')
        gl.bindAttribLocation(program, sizesAttribLocation, 'size')

        gl.linkProgram(program)
        gl.validateProgram(program)

        gAttribLocationViewportSize = gl.getUniformLocation(program, 'viewport_size')

        gl.deleteShader(vs)
        gl.deleteShader(fs)

        vao = gl.createVertexArray()
        gl.bindVertexArray(vao)

        gl.enableVertexAttribArray(verticesAttribLocation)
        gl.enableVertexAttribArray(positionsAttribLocation)
        gl.enableVertexAttribArray(colorsAttribLocation)
        gl.enableVertexAttribArray(sizesAttribLocation)

        // Add vertices
        for (let i = 0; i < numVerticesPerCircle; ++i) {
            const cont = i * Math.PI * 2 / numVerticesPerCircle
            vertices.push(Math.cos(cont), Math.sin(cont))
        }

        const spawnParticle = () => {
            positions.push(randFloat(0, canvasWidth), randFloat(0, canvasHeight))
            colors.push(randFloat(0,1),randFloat(0,1),randFloat(0,1),randFloat(0.5,1))
            // colors.push(textColor.r,textColor.g,textColor.b,textColor.a)
            sizes.push(particleSize)
            velocities.push(randFloat(-10, 10), randFloat(-10, 10))
            primitiveCount += 1
        }

        updateValues()
        for (let i = 0; i < desiredPrimitiveCount; ++i)
            spawnParticle()

        const createArrayBuffer = (loc, data, data_members, target, usage, divisor = 0) => {
            const vbo = gl.createBuffer()
            gl.bindBuffer(target, vbo)
            gl.bufferData(target, data, usage)
            gl.vertexAttribPointer(loc, data_members, gl.FLOAT, false, 0, 0)
            gl.enableVertexAttribArray(loc)
            if (divisor !== 0) {
                gl.vertexAttribDivisor(loc, divisor)
            }
            return vbo
        }

        vbo.set('vertices', createArrayBuffer(
            verticesAttribLocation,
            new Float32Array(vertices),
            2,
            gl.ARRAY_BUFFER,
            gl.DYNAMIC_DRAW
        ))
        vbo.set('positions', createArrayBuffer(
            positionsAttribLocation,
            new Float32Array(positions),
            2,
            gl.ARRAY_BUFFER,
            gl.DYNAMIC_DRAW,
            1
        ))
        vbo.set('colors', createArrayBuffer(
            colorsAttribLocation,
            new Float32Array(colors),
            4,
            gl.ARRAY_BUFFER,
            gl.DYNAMIC_DRAW,
            1
        ))
        vbo.set('sizes', createArrayBuffer(
            sizesAttribLocation,
            new Float32Array(sizes),
            1,
            gl.ARRAY_BUFFER,
            gl.DYNAMIC_DRAW,
            1
        ))

        await draw()
    })

</script>
